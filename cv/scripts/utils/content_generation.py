from datetime import date
import sys
import os
from pathlib import Path
import json
from typing import Dict, Tuple
import scripts.utils.style_console_text as sty
# Enums
from enum import EnumMeta  # an alias of EnumType in 3.11+, so can still use it
from scripts.enums.OutputTypes import OutputType


def import_contents_and_settings(path: str, type: str, version: str, lang: str) -> Tuple[Dict, Dict]:
    """ Function to dynamically import a dictionary from a different path by adding it to the recognized paths

    Args:
        path (str): path to the folder where the contentDict is located
        type (str): type of content (e.g. experience, education, etc.)
        version (str): version of the content (e.g. full, generic, etc.)
        lang (str): language of the content (e.g. en, de, etc.)

    Returns:
        tuple: tupple containing the content dictionary and the settings dictionary
    """
    sys.path.insert(0, path)
    # __import__ works like "from ... import ...", but import can be decided at runtime
    module_content = __import__(type, fromlist=[f"contentDict_{version}_{lang}"])
    contentDict = getattr(module_content, f"contentDict_{version}_{lang}")
    # Settings
    module_settings = __import__(type, fromlist=[f"generation_settings"])
    settings = getattr(module_settings, f"generation_settings")
    # Return content and settings
    return contentDict, settings


def getTemplateFolder(settings: Dict, filetype: str) -> str:
    """get the template folder from the settings dictionary

    Args:
        settings (Dict): settings dictionary containing the template paths
        filetype (str):  type of file to be generated (e.g. tex, html, etc.)

    Returns:
        str: template folder path, which may be empty if no template is specified
    """
    template = settings.templates[filetype]
    # template = template+"/" if template != "" else ""
    return template


def generate_contents(
    source_dict: dict,
    template_path: str,
    pre_content: str = "",
    post_content: str = "",
    inbetween_content: str = "",
    output_type: OutputType = OutputType("tex"),
) -> str:
    """function to generate the content of a file from a template and a dictionary
    This function will replace the placeholders in the template with the values from the dictionary and return the generated content as a string.

    Args:
        source_dict (dict): dictionary containing the content to be generated
        template_path (str): path to the template file to be used for generation
        pre_content (str, optional): Content to be added right at the beginning of the generated string. Defaults to "".
        post_content (str, optional): Content to be added right at the end of the generated string. Defaults to "".
        inbetween_content (str, optional): Content to be added between each generated piece of content that makes up the generated string. Defaults to "".
        output_type (OutputType, optional): Tpe of output generated by the script. Defaults to OutputType("tex").

    Returns:
        str: generated content as a string with placeholders replaced by values from the dictionary
    """
    # Create subtemplate path from template path
    subtemplate_path = getSubtemplatePath(template_path, output_type)
    # Define the generated content as a string
    generated_content = r""""""
    # Iterate over each entry in provided dictionary
    for i, (entry_key, entry_obj) in enumerate(source_dict.items()):
        # Get list of non-special attributes of entry class
        entry_obj_attributes = get_obj_attributes(entry_obj)
        # Read contents of template file:
        with open(template_path, "r") as template_file:
            template_content = template_file.read()
            # Replace placeholder strings in template to generate an entry
            new_content = replace_placeholders_in_template(
                template_content,
                entry_obj_attributes,
                entry_obj,
                output_type,
                subtemplate_path,
            )
            # Add newly create entry into the output file
            generated_content += new_content

            ### add inbetween content as long as last entry is not reached
            if i != (len(source_dict) - 1):
                generated_content += inbetween_content
    ### add prefix and suffix
    generated_content = f"{pre_content}{generated_content}{post_content}"
    # Return generated string
    return generated_content


def get_obj_attributes(obj: object) -> list:
    """get a list of attributes of an object, excluding special attributes (those starting with "__")

    Args:
        obj (object): Object to get attributes from

    Returns:
        list: list of attributes of the object
    """
    # Get list of non-special attributes of entry class
    obj_attributes = [a for a in dir(obj) if not a.startswith("__")]
    # Sort by descending order
    obj_attributes = sorted(obj_attributes, key=len, reverse=True)
    # print(obj_attributes)
    return obj_attributes


def replace_placeholders_in_template(
    template: str,
    placeholder_strings: list,
    entry_object,
    output_type: OutputType,
    subtemplate_path: str = "",
) -> str:
    """Function to iterate over attributes and replace them into the template

    Args:
        template (str): template string to be used for generation
        placeholder_strings (list): list of strings to be replaced in the template
        entry_object (_type_): _object to be used for generation, from which the attributes are taken
        output_type (OutputType): output type of the generated file (e.g. tex, html, etc.)
        subtemplate_path (str, optional): Path to subtemplate to be used and included into template, if any exists. Defaults to "".

    Returns:
        str: template with placeholders replaced by values from the entry object
    """
    for attr in placeholder_strings:
        kv_pair = getattr(entry_object, attr)
        key = kv_pair[0]
        val = kv_pair[1]
        # if date, format properly
        val = formatDate(val)
        # if string, format properly
        val = formatString(val)
        # if list of subObjects, format properly
        val = formatSubObjects(val, output_type, subtemplate_path)
        # Replace in template
        template = template.replace(f"KEY_{attr}", str(key))
        template = template.replace(f"VAL_{attr}", str(val))
    return template


def generate_output_file(output_content: str, output_file_path: str) -> None:
    """function to generate the output file at the specified path
    This function will create the file if it does not exist and write the generated content into it.

    Args:
        output_content (str): contents to be written into the file
        output_file_path (str): location of the file to be created
    """
    # Open a new file and write the generated content into it
    # Check whether the specified path exists or not
    output_file_dir = os.path.dirname(output_file_path)
    isExist = os.path.exists(output_file_dir)
    if not isExist:
        # Create a new directory because it does not exist
        os.makedirs(output_file_dir)
        print("The new directory is created!")
    with open(output_file_path, "w") as output_file:
        output_file.write(output_content)
    print("\n")
    print("+++++++++++++++++++++++++++++++++++++++++")
    print(f"✅ {sty.green}Output file generated successfully!{sty.reset} ✅")
    print("+++++++++++++++++++++++++++++++++++++++++")
    print(f"Output: {sty.blue}{output_file_path}{sty.reset}")
    print("\n")


def formatDate(var: any) -> any:
    """function to format a variable into a string if it is a data object, and do nothing otherwise.
    This function will convert a date object into a string in the format YYYY-MM-DD.

    Args:
        var (any): variable to be formatted as a string, if it is a data object

    Returns:
        any: transformed variable, if it was a date object, or the original variable otherwise
    """
    if type(var) == date:
        var = var.strftime("%Y-%m-%d")
    return var


def formatString(var: any) -> any:
    """Function to format a string variable, and do nothing if it is not a string.

    Args:
        var (any): variable to be formatted as a string, if it is a string

    Returns:
        any: transformed variable, if it was a string, or the original variable otherwise
    """
    # if type(var) == str:
    #     var = var
    return var


def checktype(obj: any, type: any) -> bool:
    """Cjeck if an object is a list and contains only elements of a given type.
    This function will return True if the object is a list and all its elements are of the specified type, and False otherwise.

    Args:
        obj (any): object to be checked
        type (any): type to be checked against

    Returns:
        bool: True if the object is a list and all its elements are of the specified type, False otherwise
    """
    return bool(obj) and all(isinstance(elem, type) for elem in obj)


def formatSubObjects(list_subobjs:list[object], output_type: OutputType, subtemplate_path: str) -> any:
    """function to format a list of sub-objects into a string, using a subtemplate.
    This function will iterate over the list of sub-objects and replace the placeholders in the subtemplate with the values from the sub-objects.

    Args:
        list_subobjs (list[object]): list of sub-objects to be formatted, if it is not a list, it will be returned as is
        output_type (OutputType): output type of the generated file (e.g. tex, html, etc.)
        subtemplate_path (str): path to subtemplate to be used and included into template, if any exists.

    Returns:
        any: either the formatted string of sub-objects, or the original object if it is not a list
    """
    # check if it is a list AND contains only sub-objects
    if type(list_subobjs) == list and checktype(list_subobjs, object):
        # empty string to be filled
        generated_content = """"""
        # iterate over object
        for subobj in list_subobjs:
            # get attributes of sub-objects
            entry_obj_attributes = get_obj_attributes(subobj)
            # read subtemplate
            with open(subtemplate_path, "r") as template_file:
                templateItem_content = template_file.read()
                # replace placeholders in subtemplate (this should make the function recursive!)
                new_subcontent = replace_placeholders_in_template(
                    template=templateItem_content,
                    placeholder_strings=entry_obj_attributes,
                    entry_object=subobj,
                    output_type=output_type,
                )
            # keep adding to string
            generated_content += new_subcontent + "\n"
        return generated_content
    else:
        # Leave as is if not a list of subobjects
        return list_subobjs


def print_instructions(script_name_obj: str, *args: dict) -> None: # kwargs is a dictionary
    """ print instructions on how to use the command line interface for this module

    Args:
        script_name_obj (str): name object where the dotted path to the script is stored
    """
    module_name = sys.modules[script_name_obj].__spec__.name

    print(
        f"""
    \t =================================================================
    \t HOW TO USE THIS COMMAND:
    \t {sty.blue} python[3] -m {sty.yellow} {module_name} {sty.cyan} {" ".join(f"<{la}>" for la,de,ex in args)}{sty.reset}
    """
    )
    # Print list of arguments and their definitions
    for label, definition, enum in args:
        availanle_options = ", ".join([f"{sty.blue}{e.value}{sty.reset}" for e in enum])
        print(f"\t\t► {sty.green}{label}{sty.reset} : {definition} ({availanle_options})")
    # Print use case example, if an enum has been passed, print first element of it
    print(
        f"""
    \tEXAMPLE:{sty.blue} python[3] -m {sty.yellow} {module_name} {sty.cyan} {" ".join([(list(ex)[0].value if isinstance(ex, EnumMeta) else ex) for la,de,ex in args])}{sty.reset}
    \t=================================================================
    """
    )


def generate_json(inputDict: dict, profile: str, name: str, version: str, lang: str) -> None:
    """Function to Convert objects to dictionaries, and save them as a json file.

    Args:
        inputDict (dict): input dictionary containing the objects to be converted
        profile (str): profile to be used for the output file
        name (str): section or constants name to be used for the output file
        version (str): version of the content (e.g. full, generic, etc.)
        lang (str): language of the content (e.g. en, de, etc.)
    """
    merged_data = {}
    for label, obj in inputDict.items():
        merged_data[label] = obj.__dict__

    # save dictionary as json
    with open(f"../../profiles/{profile}/webpage/data/{name}_{version}_{lang}.json", "w") as outfile:
        json.dump(merged_data, outfile, indent=4, sort_keys=True, default=str)


# default message for auto generated content
auto_warning = f" /!\\ CONTENT GENERATED WITH PYTHON SCRIPT, CHANGES MADE DIRECTLY HERE MAY BE OVERWRITTEN /!\\ "

def getSubtemplatePath(template_path: str, output_type: OutputType) -> str:
    """ Create subtemplate path from template path

    Args:
        template_path (str): template path
        output_type (OutputType): output type of the generated file (e.g. tex, html, etc.)

    Returns:
        str: subtemplate path, which is the same as the template path but with "template" replaced by "sub-template"
    """
    return template_path.replace(f"/template.{output_type.name}", f"/sub-template.{output_type.name}")
